---
title: "Reading and Summarizing JSON Data"
author: "Avy Harvey"
date: "6/2/2020"
output: html_document
#output: rmarkdown::github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

This goal of this vignette is to show how to read and summarize a JSON data set in R. The JSON data used in the examples is from the National Hockey League REST API.

## JSON 101

**JSON** (JavaScript Object Notation) is a text-based, lightweight, structured data format that's easy to read and write. It's also easy for computers to read and write! JSON is a very common format used by web-based APIs (i.e., REST APIs) to transfer data between a client and server, and is used to store data in some popular NoSQL databases, such as MongoDB.

The beauty of the JSON format is in its simplicity. The main building block of JSON data is the **name-value pair** (also called key-value pairs). JSON **objects** are made up of zero or more name-value pairs. We'll be working with NHL data, so let's describe the Carolina Hurricanes NHL franchise using the JSON format. JSON objects start with `{` and end with `}`. In between, we can specify name-value pairs, such as `name: "Carolina Hurricanes"`, or `city: "Raleigh"`. Let's combine these ideas to start describing the Carolina Hurricanes as a JSON object:

```
{
  name: "Carolina Hurricanes",
  city: "Raleigh"
}
```

You may notice that the two name-value pairs above are separated by a comma (`,`) character. This is how the JSON format is able to tell when one name-value pair ends and another begins. The whitespace (e.g., spaces, line breaks) doesn't matter, but it can make the data easier for humans to read.

Something important to note is that JSON only allows a name to exist at most once within an object. This is something that helps make JSON readable for humans and machines -- if you want to find a name in an object, you can be assured that at most one will exist. Adding a second `city: "Raleigh"` or `city: "Somewhere Else"` pair to the object would be invalid.

In the example so far, I've only used strings as values: "Carolina Hurricanes" and "Raleigh". However, JSON allows for many different types of values: strings, numbers, dates, arrays (we'll get to those), and even other objects! Here's an example that illustrates some of these types:

```
{
  name: "Carolina Hurricanes",
  location: {
    city: "Raleigh",
    state: "NC",
  },
  num_notable_players: 2,
  notable_players: ["Ron Francis", "Rod Brind'Amour"]
}
```

Now that we see how JSON objects are formed, let's talk about **arrays**. JSON arrays are lists of items. These items can be anything a JSON value can be: strings, numbers, dates, arrays, or objects. In the above example, the value of the`notable_players` key is an array of strings. When querying REST APIs, you'll likely encounter arrays frequently.

Why someone would choose to store their data in JSON format? Here are a few reasons:

- Easy to read and write
- Data relationships can be nested in the document itself (as opposed to typical RDBMS schemas)
- Lightweight textual data transfer
- Parsing/writing supported by many programming languages

These resources provide additional description and examples of JSON:

* https://www.json.org/json-en.html
* https://www.w3schools.com/js/js_json_intro.asp
* https://www.infoworld.com/article/3222851/what-is-json-a-better-format-for-data-exchange.html

## Reading JSON in R

Now that you know the basics of JSON, how can JSON data be read in R?

There are three major packages for handling JSON data:

* rjson
* RJSONIO
* jsonlite

[This page](https://rstudio-pubs-static.s3.amazonaws.com/31702_9c22e3d1a0c44968a4a1f9656f1800ab.html) shows some examples of using each of the above packages to compare behaviors, and also provides some performance metrics for parsing and writing JSON.

Each of the above packages can parse and write JSON (though each one has its own nuances). The respective methods are named `fromJSON` and `toJSON` in each package. RJSONIO and jsonlite seem to be more full-featured than rjson when it comes to prettifying (inserting whitespace to make JSON more readable for humans) and simplification. rjson is has the fastest performance of the three packages, with RJSONIO being the slowest (by far).

I'll be using jsonlite in the rest of this vignette since it is more full-featured than rjson and better performing than RJSONIO. However, you can probably adapt my examples to either of the other two packages if you like.

After installing the jsonlite package with `install.packages("jsonlite")`, let's read some data!

• Write functions to contact the NHL records ‘Franchise’ API (the previous text is a link) and return well-formatted, parsed data:
– You should have a function to return parsed data from the following calls:

∗ /franchise (Returns id, firstSeasonId and lastSeasonId and name of every team in the history of the NHL)

∗ /franchise-team-totals (Returns Total stats for every franchise (ex roadTies, roadWins, etc))

∗ /site/api/franchise-season-records?cayenneExp=franchiseId=ID (Drill-down into season records for a specific franchise)
· User should be able to specify the franchise

∗ /franchise-goalie-records?cayenneExp=franchiseId=ID (Goalie records for the specified franchise)
· User should be able to specify the franchise

∗ /franchise-skater-records?cayenneExp=franchiseId=ID (Skater records, same interaction as goalie endpoint)
· User should be able to specify the franchise

## Summarizing Data

Once you have the functions to query the data, you should perform a basic exploratory data analysis.
Not all things reported need to show something interesting or meaningful (i.e. graphs that show no
relationship are fine) but you should discuss each graph (if you don’t know hockey, that is ok - simply
discuss the graphs and summaries as best you can). A few requirements are below:

– You should create a new variable at some point
– You should create some contingency tables and numeric summaries by some of your categorical variables
– You should create some plots (at least a side-by-side bar plot, side-by-side box plots, and scatterplots with coloring)

### Numeric Summaries


### Graphical Summaries